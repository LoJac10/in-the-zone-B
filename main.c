#pragma config(Sensor, in1,    mogoLift,       sensorPotentiometer)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightDrive,     sensorQuadEncoder)
#pragma config(Motor,  port2,           leftDriveFront, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mogoLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mogoRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightDriveFront, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port9,           rightDriveBack, tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * main.c - Entry point for our codebase
 * The structure of the project is as follows:
 *
 * lib/
 *   hal.c - Hardware Abstraction Layer
 *   lcd.c - LCD Library
 *   motor.c - Motor Algorithmns
 *   pid.c - General purpose PID (Super simple, basically just makes the calculation)
 *   rerun.c - Contains code for the rerun system
 * routines/
 *   auton.c - Routines for the 15-second autonomous
 *   skills.c - Routines for the 60-second programming skills
 *
 **/

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

#include "lib\rerun.c"
#include "lib\hal.c"
#include "lib\lcd.c"

#include "routines\auton.c"
#include "routines\skills.c"

void pre_auton() {
  bStopTasksBetweenModes = false;
  robotConfigure();
  startTask(handleAll);
}

task autonomous() {
  if (match.type == 0) {
    goAuton(match.routine);
  } else if (match.type == 2) {
    goSkills(match.routine);
  }
}


task usercontrol() {
  while (true) {

    updateState();

    if (match.type == 3) {
      outputStateCode();
    }

    wait1Msec(20);
  }
}
